import logging

from asgiref.sync import sync_to_async
from django.contrib.postgres.fields import ArrayField
from django.db import models

from {{ cookiecutter.project_slug }}.common.models import AbstractBaseModel

from .exceptions import BadTemplateException

LOGGER = logging.getLogger(__name__)


class Fingerprint(AbstractBaseModel):
    name = models.TextField(
        help_text="Name of this fingerprint pattern (e.g., 'Imposter Syndrome', 'Not Connecting with Employees')"
    )
    example_dialogue = models.TextField(
        help_text="Example dialogue demonstrating this pattern in conversation"
    )

    def __str__(self):
        return self.name

    class Meta:
        ordering = ["name"]


class Feedback(AbstractBaseModel):
    class FeedbackType(models.TextChoices):
        GOOD = "GOOD", "Good Response"
        NEUTRAL = "NEUTRAL", "Neutral Response"
        BAD = "BAD", "Bad Response"

    feedback_type = models.CharField(
        max_length=10,
        choices=FeedbackType.choices,
        help_text="Quality rating of the LLM's response",
    )

    messages = ArrayField(
        models.TextField(), help_text="List of all messages in the conversation up to this point"
    )

    original_response = models.TextField(
        null=True, blank=True, help_text="The response originally generated by the LLM"
    )

    corrected_response = models.TextField(
        null=True, blank=True, help_text="Feedback about how the LLM could have responded better"
    )

    detected_pattern = models.ForeignKey(
        "Fingerprint",
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        help_text="The conversation pattern that was detected, if any",
    )

    notes = models.TextField(
        null=True, blank=True, help_text="Additional notes about why this response was good/bad"
    )

    def __str__(self):
        return f"{self.feedback_type} - {self.created.strftime('%Y-%m-%d %H:%M')}"

    class Meta:
        ordering = ["-created"]
        indexes = [
            models.Index(fields=["feedback_type"]),
            models.Index(fields=["created"]),
        ]
        verbose_name_plural = "Feedback"


class PromptTemplateManager(models.Manager):
    def get_assembled_prompt(self, agent: str | None = None):
        """Returns the assembled system prompt using all templates and fingerprints"""
        from .models import Fingerprint  # Local import to avoid circular dependency

        # Get active templates ordered by order field
        templates = self.get_queryset().order_by("order")

        # Filter by agent if specified
        if agent:
            templates = templates.filter(agent_types__contains=[agent])

        # Get all fingerprints and sort by name
        fingerprints = Fingerprint.objects.all().order_by("name")

        # Build the template variables
        dialogue_examples = []
        categories = []

        for i, fp in enumerate(fingerprints, 1):
            dialogue = f"\n# Dialogue {i} ({fp.name})\n\n{fp.example_dialogue}"
            dialogue_examples.append(dialogue)
            categories.append(f"{i}. {fp.name}")

        # Format template variables
        template_vars = {
            "categories": "\n".join(categories),
            "fingerprint_dialogue_examples": "\n".join(dialogue_examples),
        }

        # Apply variables to each template and combine them
        formatted_templates = []
        for template in templates:
            try:
                formatted_templates.append(template.content.format(**template_vars))
            except KeyError as e:
                raise BadTemplateException(
                    f"Template {template.name} includes a bad variable name: {e}"
                )

        return "\n\n".join(formatted_templates)

    async def aget_assembled_prompt(self, agent: str | None = None):
        """Async version of get_assembled_prompt"""
        return await sync_to_async(self.get_assembled_prompt)(agent=agent)


class PromptTemplate(AbstractBaseModel):
    class AgentType(models.TextChoices):
        CHAT = "CHAT", "Chat"

    name = models.CharField(max_length=255, help_text="Short descriptive name for this template")
    content = models.TextField(
        help_text="The template content. Supported placeholders are {fingerprint_dialogue_examples} like {categories}"
    )
    description = models.TextField(
        blank=True, help_text="Description of how this template should be used"
    )
    order = models.PositiveIntegerField(
        default=0, help_text="Order in which this template will appear in the system prompt"
    )
    agent_types = ArrayField(
        models.CharField(choices=AgentType.choices),
        default=list,
        blank=True,
        help_text="List of agent types this template is for. Leave empty for none.",
    )

    objects = PromptTemplateManager()

    def __str__(self):
        return f"{self.name} - {self.order}"

    class Meta:
        ordering = ["order"]
        verbose_name = "Prompt Template"
        verbose_name_plural = "Prompt Templates"
